---
template: "post"
date: 2021-05-08
title: "『JavaScript Primer』を読んだ"
emoji: 📚
category: "Book"
tags:
---

『[JavaScript Primer](https://jsprimer.net/)』の読書メモです。
ウェブサイトで公開されているものを読みました。

# 感想

業務で TypeScript を書く機会があるので、JavaScript の基本的な部分の知識を補強するために読みました。

知らないことも結構あったので、読んでよかったです。
特に、JSの基本的なクラス周りの設計や文字列の内部的な扱いなどを知らずに利用していたため、勉強になりました。

「第一部: 基本文法」と「第二部: ユースケース」に分かれていて、第一部を読めば JavaScript を読み書きするのに十分な知識が一通り身につくかと思います。

# 読書メモ

知らなかったことや、覚えておきたいことなどをメモしています。

## 第一部: 基本文法

### JavaScriptとは

- 実行コンテキストとして Script と Module がある。
  - 多くの実行環境では Script がデフォルトの実行コンテキスト。
  - Module の実行コンテキストは ES2015 で導入された。
- [MDN Web Docs](https://developer.mozilla.org/ja/) にほとんどの API のリファレンスが載っている。
  - ECMAScript だけでなく、ブラウザ固有の DOM API についても含まれている。

### データ型とリテラル

- `typeof null` が object になる仕様バグがある。知らなかった。
  ```js
  console.log(typeof null) // => object
  ```
- 数値リテラル（整数含む）は倍精度浮動小数点数として扱われる。
  - 忘れた頃にハマりそう。
- BigInt (ES2020) で任意精度の整数を扱える。
  ```js
  console.log(100000000000000000000n) // => 100000000000000000000n
  ```
- undefined はリテラルではなく、グローバル変数。知らなかった。
- プリミティブ型の値をラップしたようなラッパーオブジェクトが用意されている。
  - ラッパーオブジェクトが length プロパティなどを持つ。
  - プリミティブ型のデータのプロパティにアクセスする際に、ラッパーオブジェクトに暗黙的に変換されるので、明示的にラッパーオブジェクトを使う必要はない。

### 演算子

- 厳密等価演算子（===）は、オペランドが同じ型で同じ値である場合に true を返す。オペランドがどちらもオブジェクトである場合には、参照が同じ場合に true を返す。
- 等価演算子（==）は、オペランドの型が異なる場合には、右辺の値に対して暗黙的な型変換をしてから比較する。
  - null または undefined であることを判定する場合に使うことがある。
    ```js
    const value = undefined
    console.log(value == null) // => true
    ```
    - 便利なプラクティスではあるけど、メソッドを作ったほうが安全そう。
  - === しか使わないので、そもそも == の比較の意味を忘れていた。
- Nullish coalescing 演算子 (??) は、左辺の評価結果が null または undefined であるならば、右辺の評価結果を返す。
  - とても便利。

### 関数と宣言

- Rest parameters (ES2015) で、可変長引数を扱える。
  ```js
  function fn(a, ...rest) {
    console.log(a) // => 1
    console.log(rest) // => [2, 3]
  }
  fn(1, 2, 3)
  ```
- 再帰関数を関数式にしたい場合に、匿名関数に名前をつける方法が使える。
  ```js
  const outer = function inner(n) {
    if (n === 0) { return 1 }
    return n * inner(n - 1)
  }
  console.log(outer(3)) // => 6
  ```
  - 再帰関数を即時関数にして使いたい場合は稀にある気がする。
- 同名の関数宣言はエラーが出ずに、上書きされる。

### オブジェクト

- あらゆるオブジェクトの元となる Object というビルトインオブジェクトがある。
  - {} と書くと、Object のインスタンスオブジェクトが作成される。
- オブジェクトのプロパティ名は暗黙的に文字列に変換される。

### プロトタイプオブジェクト

- 基本的に、オブジェクトは Object.prototype プロパティに定義された prototype オブジェクトを継承している。
  - prototype オブジェクトはプロトタイプメソッドを提供するベースオブジェクト。
    ```js
    console.log(typeof Object.prototype.toString) // => "function"
    ```
  - インスタンスから Object の prototype オブジェクトのメソッドを参照できる仕組みをプロトタイプチェーンと呼ぶ。
    - この辺りの設計や仕組みは意識せずに使っていたので、初めて知った。
- ビルトインオブジェクトの Array なども同様に Array.prototype を持っており、独自のメソッドを定義している。

### 配列

- TypedArray (ES2015) で、固定長かつ型つきの配列を扱える。
- Array#flat (ES2019)で、多次元配列をフラットにできる。Infinity を値として渡すことで、全てフラットにできる。
  - Infinity を渡すのがなんだか面白い。
- Array#reverse や Array#sort などは破壊的操作であることに注意。

### 文字列

- JavaScript の文字列は内部的に UTF-16 の Code Unit (16bit) の並びとして管理される。
  - String#length は、Code Unit の個数を返す。
  - === や > などの比較演算子も、Code Unit 同士を先頭から順番に比較する。
  - [ECMA-402](https://www.ecma-international.org/publications/standards/Ecma-402.htm)という仕様で国際化についての取り決めがされており、国際化に関する API を定義した [Intl](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Intl) というビルトインオブジェクトがある。
- 正規表現オブジェクトを作成するには、正規表現リテラルと RegExp コンストラクタを使う方法がある。
  ```js
  const patternA = /パターン/フラグ
  const patternB = new RegExp("パターン", "フラグ")
  ```
  - 正規表現リテラルは、ソースコードをパースした段階で評価される。
  - RegExp コンストラクタを使う場合は、コンストラクタを呼び出した段階で評価される。
  - 正規表現リテラルを用いた方がパフォーマンスが良い。動的なパターンが必要な場合に RegExp コンストラクタを用いる。
- String#matchAll (ES2020) で、g フラグを用いた繰り返しマッチの、マッチした文字列ごとの情報を得られる。
- タグ付きテンプレート関数 (ES2015)：関数に () を付けずにテンプレート文字列を渡すと、特殊な形式でテンプレート文字列を受け取れる。
  ```js
  function tag(strings, ...values) {
    console.log(strings) // => ["template "," literal ",""]
    console.log(values) // => [0, 1]
  }
  tag`template ${0} literal ${1}`
  ```

### 文字列とUnicode

- Code Unit のエスケープシーケンスを2つ並べたものや、Code Print のエスケープシーケンスでサロゲートペアを表現できるが、内部的には Code Unit に変換された値で管理される。
  ```js
  console.log('\uD83C\uDF4E') // => 🍎
  console.log('\u{1F34E}') // => 🍎
  ```
- String#length メソッドなどは文字列を Code Unit の並びとして扱うため、注意が必要。
  ```js
  console.log('🍎'.length) // => 2
  ```
- 以下のようなものは、文字列を Code Print (Unicode文字のID) ごとに扱う。
  - CodePrint を名前に含むメソッド
  - u フラグが有効化された正規表現
  ```js
  const [allWithoutU, appleWithoutU] = '🍎だよ'.match(/(.)だよ/)
  console.log(allWithoutU) // => \uDF4Eだよ
  console.log(appleWithoutU) // => \uDF4E （下位サロゲートにマッチする）
  const [allWithU, appleWithU] = '🍎だよ'.match(/(.)だよ/u)
  console.log(allWithU) // => 🍎だよ
  console.log(appleWithU) // => 🍎
  ```
  - 文字列の Iterator を扱うもの (Array.from など)
    - Array.from が直感的に動作してくれることが意外だった。

### 関数とスコープ

- 外側のスコープへ変数定義を探しにいく仕組みをスコープチェーンと言う。
- var による変数宣言と、function による関数宣言は、最も近い関数またはグローバルスコープの先頭に巻き上げられる。代入部分は巻き上げられない。
  - 書くことはなさそうだが、覚えておかないといけない仕様。
- JavaScript はレキシカルスコープ。
  - クロージャの説明が手厚い。
- 関数もオブジェクトなのでプロパティに値を代入できるが、外から参照して変更できるため、状態をもたせたい場合はクロージャーを利用したほうがよい。

### 関数とthis

- 実行コンテキストにおけるthis
  - 実行コンテキストが Script の場合、トップレベルスコープの this はグローバルオブジェクトを参照する。
    - グローバルオブジェクトは実行環境ごとに異なる。ブラウザの場合は window オブジェクト。Node.js の場合は global オブジェクト。
    - this を使わなくても、globalThis (ES2020) を使うことでグローバルオブジェクトを参照できる。
  - 実行コンテキストが Module の場合、トップレベルスコープの this は常に undefined になる。
- Arrow Function 以外の関数における this
  - ベースオブジェクト（レシーバ）を参照する。ベースオブジェクトが無い場合は undefined になる。
  - ただし、strict mode でない場合には、this が undefined の場合にグローバルオブジェクトを参照するように変換される場合がある。
  - オブジェクトのメソッドを変数に代入して関数として呼び出した場合などに、this が意図しない参照になる可能性がある。
    - Arrow Function 以外の関数において、this は実行時に決定するため、参照できずに例外が送出される問題などが発生しうる。
  - Function オブジェクトにある call, apply, bind といったメソッドを使うことで、関数やメソッドの this を明示的に指定して実行することも可能である。
  - this を一時変数に置く手法もある。
- Arrow Function における this
  - 静的に決まり、自身の外側のスコープに定義されたもっとも近い this の値を参照する。
  - Arrow Function は this を持てないため、call, apply, bind を使った this の指定は無視される。

最初の頃は this がかなりややこしいと感じていたが、こうやってパターン化されると初学時でもすんなりと覚えられそう。

### クラス

- class 構文で定義したクラスは関数オブジェクトの一種。
  - わかりやすさのために導入された構文であり、class 構文でしか実現できない機能はない。
- new 演算子でクラスのインスタンスオブジェクトを作成できる。
  - コンストラクタ内の this は作成されるインスタンスオブジェクトを参照する。
  - コンストラクタで return 文で値を返すと new 演算子で読んだときの返り値になってしまうため、値を返すべきでない。
- クラスに定義したメソッドは、各インスタンスから共有されるプロトタイプメソッドになる。
  - コンストラクタで this のプロパティにメソッドを定義することで、プロトタイプメソッドでないインスタンスのメソッドを定義することもできる。
    - Arrow Function を使えるので、this の参照先がインスタンスに固定されたメソッドを定義できる。
    - やったことがないが、少しトリッキーで面白い。
  - プロトタイプメソッドの定義には Arrow Function が使えないため、呼び出し方によって this の参照先が変わることに注意。
- アクセサプロパティで、プロパティの参照・代入の振る舞いを定義できる。
- static 構文で静的メソッドを定義できる。this はクラス自身を参照する。
- class 構文のメソッド定義は、クラス自身の prototype プロパティのプロパティに定義される。
  - プロトタイプメソッドはプロトタイプオブジェクトへ、インスタンスオブジェクトのメソッドはインスタンスオブジェクトへ定義されるため、重複して定義できる。
  - 見かけ上は定義が上書きされるだけなので特に意識したことがなかったが、面白い仕様だと思った。
- インスタンスからプロトタイプメソッドを呼び出せるのは、プロトタイプチェーンという仕組みによるもの。
  - インスタンス作成時に、インスタンスの [[Prototype]] 内部プロパティにプロトタイプオブジェクトへの参照を保存する。
  - インスタンスからプロパティを参照するときに、[[Prototype]] 内部プロパティまで探索する。
  - Object.getPrototypeOf メソッドで、[[Prototype]] 内部プロパティを参照できる。
- クラスを継承した場合、子クラスのインスタンスから親クラスのプロトタイプメソッドも呼び出せる。（プロトタイプ継承）
  - 子クラスのプロトタイプオブジェクトの [[Prototype]] 内部プロパティに、親クラスのプロトタイプオブジェクトが設定される。
- クラスのコンストラクタも親クラスのコンストラクタとの間にプロトタイプチェーンが張られるため、静的メソッドも継承される。
- 子クラスのプロトタイプメソッドから super.プロパティ名 で親クラスのプロトタイプメソッドを参照できる。
  - 静的メソッドについても同様の記述で親クラスのメソッドを呼び出せる。

### 例外処理

- throw 文ではエラーオブジェクトを例外として投げられる。
  - Error オブジェクトのコンストラクタの第一引数に渡した文字列を、Error#message で参照できる。
  - throw 文はあらゆるオブジェクトを例外として投げられるが、スタックトレースのために、Error オブジェクトのインスタンスを投げることが推奨される。
- ビルトインエラーとして送出されるオブジェクトはすべて Error オブジェクトを継承したオブジェクトのインスタンス。

### 非同期処理

- JavaScriptの多くの非同期処理はメインスレッドで実行される。
  - Web Worker API などの一部の API は並列処理される。
- 非同期処理の外から、非同期処理の中で発生した例外を検出できないため、対応するためのパターンが複数ある。
  - エラーファーストコールバックとは、コールバック関数の引数にエラーオブジェクトと、成功時の返り値を両方返すようなコールバック関数の実装パターン。
  - 非同期処理の結果を表現する Promise オブジェクトを使うパターン。
    - Promise.race というメソッドがあるのか。
  - Async Function を使うパターン。
    - コールバック関数を async function にする場合に、コールバック関数の外側が同期的に処理されることで、意図しない挙動にならないように注意。

### Map/Set

- Map オブジェクトでハッシュマップを扱える。
  - Object ではなく Map を使った場合の利点として以下がある。
    - サイズを簡単に知れる。
    - 要素を簡単に列挙できる。
    - オブジェクトをキーにできる。
    - 意図しないキーの衝突を気にしなくて良い。
  - Object をハッシュマップとして扱う場合の利点として以下がある。
    - リテラル表現があるため作成しやすい
      - 記法の簡単さがそこまで影響するのかと思わなくもないが、Map を使うほどでもない場合に書きやすさで {} と書いてしまうことがあったかもしれない。
      - あとは、要素数が少ない場合には十分高速に動作するので、必要にならない限り Map よりも Object を使いがちかも。
    - JSON.stringify 関数を使ってJSONに変換するのが簡単。
    - 多くの関数がマップとして Object を渡される設計になっている。
      - 外部ライブラリを使うときに確かに Object をマップとして使うことがあった。キーの範囲が定まってないときなどは注意が必要だ。
  - NaN 同士の === の比較結果は false になるが、Map のキーでは NaN 同士は常に等価となる。（Same-value-zeroアルゴリズム）
    - 挙動自体は直感的で嬉しいが、この仕様を覚えられる気がしない。
- WeakMap はキーを弱い参照で持つ。
  - キーとして使えるのは参照型のオブジェクトのみ。
  - クラスにプライベートの値を格納するときなどに使える。
- WeakSet もキーを弱い参照で持つ。

### JSON

- JSON の仕様は[json.orgの日本語ドキュメント](https://www.json.org/json-ja.html)にまとまっている。
- JSON.parse メソッドで、文字列を JSON としてパースしてオブジェクトに変換できる。
  - パースに失敗した場合には例外が投げられるので例外処理を忘れない。
- JSON.stringify メソッドで、オブジェクトを JSON 形式の文字列に変換できる。
  - JSON で表現可能でない値の扱いに注意する。
    - 関数、undefined、Symbol は変換されない。（配列のときは null に置き換えられる）
    - RegExp、Map、Set などの、列挙可能なプロパティを持たないオブジェクトは {} に変換される。
    - undefined や RegExp などの扱いはハマりかねないので覚えておきたい。
  - 参照が循環しているオブジェクトをシリアライズしようとしたときなどには例外が投げられるので例外処理を忘れない。
  - オブジェクトが toJSON メソッドを持っている場合は、規定の文字列変換ではなくて toJSON メソッドの返り値が使われる。

### Date

- Date オブジェクトのインスタンスは、一つの時刻値（UNIX 時間をミリ秒として保持）を持ち、その時刻値を元に日付などを扱うメソッドを提供する。
- 多くのユースケースにおいて機能が十分でないので、外部ライブラリを使うことが一般的。

### ECMAScriptモジュール

- ECMAScript モジュールは、ES2015 で導入された JavaScript ファイルをモジュール化する機能。
  - export 文によって変数や関数をエクスポートできる。
  - import 文によって別モジュールでエクスポートされたものをインポートできる。
- ECMAScript モジュールを実行するためには、JavaScript ファイルを ECMAScript モジュールとしてブラウザに読み込ませる必要がある。
  - script 要素に type="module" 属性を付けて読み込む。

### ECMAScript

- ECMAScript は Living Standard である。
- 仕様書のドラフトは [github.com/tc39/ecma262](https://github.com/tc39/ecma262) で管理され、最新の仕様は [tc39.es/ecma262](https://tc39.es/ecma262/) に公開されている。
- Living Standard に加えて、1年毎のスナップショットである ES2015 などが公開されている。
- ブラウザに実装される際には、Living Standard の ECMAScript が参照される。

## 付録: 参考リンク集

- トランスパイラ
  - [Babel](https://babeljs.io/)：新しい ECMAScript の構文を古い ECMAScript の構文に変換することを主な機能にしたトランスパイラ
  - [TypeScript](https://www.typescriptlang.org/)：JavaScript に静的型づけの構文を追加した言語とトランスパイラ
- モジュールバンドラ
  - NPM によって Node.js 向けに配布されるライブラリの多くは CommonJS モジュールであり、そのままでは ブラウザで動作しないため、モジュールの依存関係を解消したりファイル結合をするためにモジュールバンドラが必要。
  - [webpack](https://webpack.js.org/)：CommonJS モジュールや ECMAScript モジュールの依存関係を解決し、アプリケーション向けに最適化しながらモジュールを結合する。
  - [Rollup](https://rollupjs.org/guide/en/)：主に ECMAScript モジュールの依存関係を解決し、ライブラリ向けに最適化しながらモジュールを結合する。
- コーディングスタイル
  - [Prettier](https://prettier.io/)：多くの言語に対応した汎用的なコードフォーマッタ
  - [ESLint](https://eslint.org/)：JavaScript ファイル用の Lint ツール
- ブラウザの開発者ツール
  - [Firefox 開発ツール](https://developer.mozilla.org/ja/docs/Tools)
  - [Chrome DevTools](https://developer.chrome.com/docs/devtools/)
  - [Safari Developer Help](https://support.apple.com/ja-jp/guide/safari-developer/welcome/mac)
- パフォーマンス改善
  - [PageSpeed Insights](https://pagespeed.web.dev/)：Google が提供するウェブパフォーマンス計測ツール。読み込みにかかっている時間や、改善できる項目を掲示してくれる。
  - [WebPagetest](https://www.webpagetest.org/)：ブラウザを利用したウェブパフォーマンス計測ツール。さまざまな条件下のブラウザでパフォーマンスを計測できる。
  - [Lighthouse](https://developers.google.com/web/tools/lighthouse/?hl=ja)：Google が提供するウェブページの分析ツール。アクセシビリティやSEOなども分析してスコアを計算してくれる。
- デスクトップアプリケーション
  - [Electron](https://www.electronjs.org/)：GitHub 社によって開発されているデスクトップアプリケーションフレームワーク
  - [NW.js](https://nwjs.io/)：Intel 社によって開発されているオープンソースのデスクトップアプリケーションフレームワーク
