---
template: "post"
date: 2021-01-10
title: "『ロベールのC++入門講座』を読んだ"
emoji: 📚
category: "Book"
tags:
---

『[ロベールのC++入門講座](https://www.amazon.co.jp/dp/4839926050)』の読書メモです。

# 感想

C++ の経験については、主に競技プログラミングで使っているのと、インターンシップでの業務で使用したのみで、インターネット上のリファレンスをつまみ食いしながら書いてきたような状況でした。
習熟しているとは正直言えないので、何か入門書を読んでみようと思って読みました。
内容はだいぶ古い（2007年出版）のですが、ずっと前に買って積んだままになっていたので、折角なのでこの本で再入門しました。

分厚い本なので読むのに時間はかかりましたが、コード例が豊富なので、内容の読解に苦労するところはなかったように思います。
やはりというか、知らない知識が結構あり、読んでよかったです。
新規格に対応した新しい本を読んだほうが better だとは思いますが、この本を読んである程度知識の穴埋めをできたと思うので、ひとまず満足しています。

# 読書メモ

## 第1章 まずは使い方

- 開発環境についてなど。

## 第2章 C++の基本

- 関数、入力、for 文などについて。

## 第3章 ほんの少し深く

- 型、参照、文字コード、文字列、関数プロトタイプ、include、オーバーロードなどについて。

## 第4章 ポインタ天国

- アドレス、ポインタ、配列、const、ヌルポインタ などについて。
- 参照は初期化時にしか参照先を決められない。ポインタはアドレスを再代入できる。
- 関数の仮引数を配列変数にしても、実体はポインタとなる。
  - sizeof pointer はポインタのサイズになるので注意。
- n 要素の配列の有効な要素のインデックスは n-1 までだが、有効なアドレスのインデックスは n までとなる。知らなかった。

## 第5章 クラスの前に

- 多次元配列、構造体、列挙体、デフォルト引数、静的ローカル変数、スコープ、リンケージ、分割コンパイル、文字列リテラル、new/delete などについて。
- デフォルト引数には静的な値のみ指定できる。
- オーバーロードとデフォルト引数の併用は、呼び出しが区別できるかどうかに注意。
- 文字列リテラル
  - 書き換えてはならない
  - 寿命はプログラムが終わるまで
  - 文字列リテラルはそのアドレスを返す

## 第6章 クラスの基礎

- メンバ関数、コンストラクタ、デストラクタ、コピーコンストラクタ、演算子オーバーロード、constメンバ関数などについて。
- デフォルトコンストラクタ
  - 基本型のメンバ変数は初期化されず、コンストラクタを持つ型のメンバ変数はデフォルトコンストラクタで初期化される。
  - デフォルトコンストラクタ以外のコンストラクタを作った場合はデフォルトコンストラクタは自動で作られない。
- exit 関数でプログラムを終了した場合、静的変数のデストラクタは呼ばれるが、自動変数のデストラクタは呼ばれない。
- コピーコンストラクタは仮引数を作るときに呼ばれる。
  - 初期化ではコピーコンストラクタが、代入では operator= が呼ばれる。
- 自分で定義しない場合にはデフォルトの operator= が作られ、各メンバ変数にコピー元のメンバ変数が代入される。

## 第7章 クラスの本領

- 継承、アップキャスト、オーバーライド、仮想関数、純粋仮想関数、動的確保、仮想デストラクタなどについて。
  - うっかりでとんでもないバグを仕込んでしまいがちなところなので、ちゃんと覚えて気を付けよう。
- アップキャスト
  - 基底クラスへの参照やポインタに、派生クラスのオブジェクトやそのアドレスを渡せる。
  - 仮想関数は、基底クラスへの参照やポインタを通しても本来の型によって適切に呼び分けられる。
    - 逆に、仮想関数でない関数をオーバーライドすると、派生クラスをアップキャストした場合に基底クラスのメンバ関数が呼ばれてしまう。
- 純粋仮想関数を持つクラス（抽象クラス）は実体を作ることができない。抽象クラスの参照やポインタは作れる。
  - 純粋仮想関数が1つでもオーバーライドされていない場合、派生クラスも抽象クラスとなる。
- int 型や double 型などデフォルトで提供されるコンストラクタしか持たない型を POD (plain old data) 型という。
  - メンバ変数が POD 型のみで構成され、独自のコンストラクタが定義されていないクラスも POD 型となる。
  - POD 型は、変数宣言時に初期化をしなければ、デフォルトコンストラクタも呼ばれない。
- 基底クラスのコンストラクタやデストラクタで仮想関数を使うと、基底クラスのメンバ関数が呼ばれることに注意。
  - 基底クラスのコンストラクタが実行されている時点では、派生クラスのコンストラクタは実行されていないため。
- 仮想関数は、仮想関数テーブルという隠しメンバ変数を使って実現される。
- 同じ基底クラスを持つ別のクラスを作りたい場合は、オブジェクトを動的に確保して基底クラスへのポインタに入れて扱う。
  - 一連のクラスのオブジェクトを動的に生成して返すクラスをファクトリクラスという。
- 基底クラスへのポインタで派生クラスを確保したときに派生クラスのデストラクタが呼ばれないというバグが生じうるため、デストラクタは基本的に仮想関数にするべき。
  - 例外的に、仮想関数テーブルの大きさが問題になる場合に非仮想デストラクタを採用する場合がある。

## 第8章 ファイルとストリーム

- ファイル操作、オープンモード、ファイルポインタ、iostream、マニピュレータ、名前空間などについて。
- cout と同様、ファイル出力の場合も flush や endl をしないと、すぐにファイルに出力されない場合がある。
- ファイルの内容を変更するモードにはバイナリモードとテキストモードがある。これらは改行コードの扱いについてのみ異なる。
  - テキストモードでは改行が \n として読み出され、OS に合わせた形で書き込まれる。
- 値をバイナリ形式のままで入出力する場合には write/read を使う。
  - バイナリ形式のデータの表現方法（バイトオーダ）は環境によって異なることに注意。
- マニピュレータでストリームの処理を制御できる。
  - 効果が1度きりのものと、続くものがある。
- 名前空間
  - namespace 構文で名前空間に別名を与えることができる。
  - 関数内でも using 指令を使うことができる。
  - 影響範囲が大きすぎるため、ヘッダファイルで using は使うべきでない。
  - 無名名前空間を作ると、無名名前空間を含む名前空間内に関数があるかのように扱える。

## 第9章 テンプレート

- 関数テンプレート、クラステンプレート、デフォルトテンプレート引数などについて。
- 関数テンプレートは型に合わせた実体を適宜作る。
  - 関数テンプレートの実装は、実体を作るところから見えなくてはならない。
  - 関数テンプレートは `template int Abs(int a);` のようにすると、明示的に実体化できる。特定の型のみで実体化したいときなどに利用できる。
- クラステンプレートはテンプレート引数にデフォルト引数をとることができる。
- テンプレートと継承の違い
  - テンプレートはファイルサイズや動的な処理の切り替えを犠牲にすることで高速に動作する。
  - 継承は速度を犠牲にすることでファイルサイズが小さくなり動的な処理の切り替えを行うことができる。

## 第10章 エラー処理と例外

- goto文、例外、標準例外クラス、例外指定などについて。
- 例外
  - 最後まで例外が捕捉されなかった場合には terminate 関数が呼ばれて異常終了する。この場合、デストラクタが呼ばれない可能性がある。
  - `catch(...)` ですべての例外を捕捉できる。基本的には使うべきでない。
  - catch 節内なら、`throw;` だけで例外を再送出できる。
  - 例外は普通、参照で受け取る。参照で受けると、catch 節を抜けるときにオブジェクトの寿命が尽きる。
  - 関数宣言の最後に `throw( 例外型リスト )` と書くと、その関数がその型の例外しか投げないことを宣言できる（例外指定）。
- コンストラクタで投げられた例外
  - コンストラクタで例外が外に投げられた場合、そのクラスのデストラクタは呼ばれない。
  - コンストラクタの初期化しで例外が投げられた場合、その例外は必ず再送出される。
  - 二重例外になる場合があるため、デストラクタでは例外を外に投げるべきでない。
  - コンストラクタでの例外まわりのことを把握していなかったので、気をつけよう。

## 第11章 もっと高く

- 静的メンバ変数、静的メンバ関数、メンバ定数、テンポラリオブジェクト、演算子オーバーロード、キャストなどについて。
- 静的メンバ変数
  - すべての実体で共有される。
  - 実体を別に宣言する必要がある。
  - 派生しても静的メンバ変数は1つしか作られない。クラステンプレートの静的メンバ変数や関数テンプレートの静的ローカル変数はテンプレート引数ごとに異なる実体が作られる。
- メンバ定数には代入できない。コンストラクタ初期化子で初期化する。
- テンポラリオブジェクト
  - コンストラクタを直接呼ぶ形で書くと、テンポラリオブジェクトが作成される。
  - テンポラリオブジェクトの寿命はその文が終わるまで
  - `string str = string("hoge");` などと書くと、コピーコンストラクタが走らない形に最適化される場合があるが、その場合でも、文法はコピーコンストラクタが呼ばれる形でチェックされる。
  - const 参照に即値を入れるとテンポラリオブジェクトが作成される。
  - const 参照をテンポラリオブジェクトで初期化すると、テンポラリオブジェクトの寿命が const 参照の寿命と等しくなる。
  - 関数の戻り値のコピーは代入演算子ではなくコピーコンストラクタで行われる。ただし、戻り値最適化により、コピーコンストラクタが呼ばれない可能性がある。
- 代入式は左辺値。
- 演算子オーバーロード
  - `operator[]` などで参照を返すようにすれば、戻り値への代入などが行える。
  - this を使うとメンバ関数を呼び出したオブジェクトのアドレスを取得できる。
  - 後置インクリメントをオーバーロードするには、int 型のダミー引数をとる。
  - クラスが右項になる場合はクラス外で演算子オーバーロードする。
  - クラス内で friend 関数プロトタイプを宣言すると、その関数内で private メンバにアクセスできる（ただし、メンバ関数にはならない）。
- 実引数1つだけで呼べるコンストラクタは暗黙的キャストが行われる（デフォルト引数の存在によって、実引数1つで呼べるものも含む）。
  - 基本的には explicit を付けて暗黙的キャストを防ぐべき。

## 第12章 もっともっと高く

- ビット演算、インライン関数、typedef、マクロなどについて。
- インライン関数
  - 呼び出し部分に処理を埋め込むことができる。ただし、必ず展開されるわけではない。
  - クラスのメンバ関数も、実装時に inline を書くとインライン関数にできる。
  - クラス宣言の中でメンバ関数を実装すると、それだけでインライン関数になる（ヘッダファイルを変更することになるので再コンパイルが必要なため、小さいプログラム以外ではやらないほうが良い）。
- マクロの正しい使い方
  - マクロ引数を2度以上使用するマクロに、2度以上実行されてはいけない変数を渡さない。
  - マクロ定義内で改行したい場合には行の終端に \ を付けて行連結する。
  - マクロの有効範囲はソースファイルの終端まで。

## 第13章 もっと深く

- 多重継承、仮想継承、インタフェースクラス、ダウンキャスト、クロスキャスト、フレンド、不完全型、using、テンプレートの特殊化、関数ポインタ、メンバ関数ポインタ、メンバ変数ポインタなどについて。
  - テンプレート関連の節以外はほとんど、見たことはあっても詳細を知らないものばかりだった。
  - おそらく多重継承を自分で書くことはないが、勉強になった。
  - 関数ポインタの記法がややこしい。
- 多重継承
  - 1度に同じクラスを直接2つ継承することはできないが、間にクラスを挟めば同じクラスを複数継承できる。この場合、仮想関数をオーバーライドすると、すべての仮想関数が同じ形でオーバーライドされる。
  - アップキャスト先が曖昧になる場合には、途中のクラスにいったんアップキャストする必要がある。
- 仮想継承
  - 同じクラスを仮想継承しない場合、その全てにメンバ変数が独立に作られる。
  - 同じクラスを virtual キーワードを使って仮想継承した場合、そのクラスは全て共有される。
  - 仮想継承したクラスのコンストラクタは、実際に構築しようとしているクラスで指定したものが呼ばれる。
  - 仮想継承したクラスの仮想関数の実装は同時に1つしか存在してはいけない。
  - 仮想継承を使うと、直接アップキャストできる。
- インタフェースクラス
  - 仮想デストラクタ以外には純粋仮想関数しかないクラスのこと。多重継承した場合でも、継承の経路を考える必要がない。
- typeid 演算子で、実行時型情報 (Run-Time Type Information: RTTI) を得られる。
- dynamic_cast を使うと、ダウンキャストに失敗した場合に例外を捕捉できる。また、dynamic_cast を使うと、直接クロスキャスト（継承木を下がって上がるキャスト）できる。
- フレンド指定されたクラスや関数からは、元クラスのアクセス指定を無視できる。フレンド指定は一方通行。
- 不完全型
  - `class クラス名;` とすれば不完全型を定義できる。
  - 2つのクラスが相互参照している場合などに使う。
- using 指令は、指定した名前空間の識別子を現在のスコープに取り込む。
  - 基底クラスに同名の関数が複数ある場合に、そのうち1つだけを派生クラスでオーバーライドしたいときなどに、冗長な再定義を避けるためなどにも using が使える。
- テンプレート引数
  - テンプレート引数に、クラステンプレートを実体化しないまま入れることができる。
  - テンプレート引数に、静的な整数定数やポインタを入れることができる。
- テンプレートの特殊化
  - クラス宣言で特殊化すると、既存のメンバ宣言が全て無視される。
  - 実体定義で特殊化すると、そのメンバのみが特殊化される。
  - クラステンプレートの一部だけを特殊化できる（部分特殊化）。
- 汎整数昇格
  - int より下の型の値が指揮中に現れた場合、int か unsigned int に暗黙的にキャストされる。
- 関数ポインタ
  - `戻り値の型 (* 変数名)(仮引数リスト);` と宣言する。
  - 型名は `戻り値の型 (*)(仮引数リスト)` になる。
- メンバ関数ポインタ
  - `戻り値の型 (クラス名::*)(仮引数リスト);` と宣言する。
  - 型名は `戻り値の型 (クラス名::*)(仮引数リスト)` になる。
  - メンバ関数ポインタを使うには .* や ->* 演算子を使う。関数呼び出しの括弧よりも優先度が低いので、`calc.*(mfp());` のようにする必要がある。
  - this->* は省略できない。
  - 仮想関数の呼び出しも適切に処理される。
  - 特殊な表現を取るため、普通のポインタのサイズと等しいとは限らない。
- メンバ変数ポインタ
  - 構造体中のアドレスを示すようなポインタ。
  - `参照先の型 クラス名::*変数名;` と宣言する。
  - メンバ変数ポインタを使うには .* や ->* 演算子を使う。
  - メンバ変数ポインタは 0 になりうるので、メンバ変数ポインタのヌルポインタは 0 にならない可能性がある。

## 第14章 もっともっと深く

- ショートサーキット、処理系依存/未定義/未規定、void ポインタ、#if、組み込みマクロ、可変長引数、main の戻り値、コマンドライン引数、強制終了、アラインメント、プリコンパイル済みヘッダファイルなどについて。
- 仕様の表現
  - 処理系依存の動作：処理系によって独自に定義されることを許した動作。
    - int 型のサイズなど。
  - 未定義の動作：間違ったプログラムの引き起こす動作。
  - 未規定の動作：正常なコードの中で起こりうる基底されていない動作
    - 関数に複数の実引数を渡した場合、それらの評価される順番は未規定。
- void ポインタ
  - ほとんどのポインタをキャストなしで代入できる。
  - ポインタから直接参照先へはアクセスできない。他のポインタへ代入するにはキャストをする。
  - 任意の型のアドレスを受け取りたい場合に使う。
- プリプロセッサディレクティブ
  - `#if ~ #endif` でコンパイルするかを制御できる。条件式には、コンパイル前に決まる値しか使えない。
- 組み込みマクロ
  - `__FILE__` はファイル名、`__LINE__` は行番号に置き換わる。
- 関数の引数を `...` にすれば可変長引数を取れる。
- main の戻り値
  - main 関数の実行前のグローバル変数の動的初期化や、main 関数終了後の全静的変数の終了処理を行うルーチンを、スタートアップルーチンという。
  - スタートアップルーチンは main 関数の戻り値を使って exit 関数を実行する。
  - 終了状態（exit 関数の引数）は、プログラムを実行した存在へ、環境依存の形で伝えられる。
- exit 関数は静的変数のデストラクタを実行してプログラムを終了する。abort 関数はデストラクタを呼ばずにプログラムを異常終了する。
- アラインメント
  - 構造体やクラスのメンバ変数は、データがバイト境界をまたがないように配置される。そのため、環境依存のパディング分、容量が大きくなる。
  - 構造体の先頭からのメンバ変数の位置を offsetof マクロで取得できる。
  - `#pragma` でアラインメントを調整できる。また、alignas で言語的にアラインメントを調整できる。
- ヘッダファイルを予めコンパイルしておくことができる。

## 第15章 データ構造

- リスト、イテレータ、スタック、キュー、placement new、再帰関数、ツリー、二分探索木、ハッシュなどについて。
- イテレータ：ポインタのように振る舞うクラス
- placement new
  - `new (アドレス)` とすると、指定したアドレスにあるメモリを使ってコンストラクタを呼べる。
    - 自前 vector を作れるようになった。
- new/delete 演算子のオーバーロード
  - オーバーロードされた new 演算子を使用した場合、operator new が呼ばれ、返されたアドレスを使ってコンストラクタが呼ばれる。
  - オーバーロードされた delete 演算子を使用した場合、デストラクタが呼ばれ、その後 operator delete が呼ばれる。
  - new 演算子をオーバーロードした場合、対応する delete 演算子を必ずオーバーロードする必要がある。
  - ただし、引数付きの delete 演算子は operator delete の形でしか呼べない。この場合、デストラクタが呼ばれない。

## 第16章 C++の落ち穂拾い

- 共用体、無名構造体、ビットフィールド、可変長配列メンバ、コンマ演算子、トークン連結演算子、文字列化演算子、配列へのポインタ、extern "C"、volatile、terminate などについて。
- 共用体のメンバ変数は同じメモリ領域を共有する。
- 名前のないクラス・構造体・共用体・列挙体を作ることができる。
  - 無名共用体をクラスの変数として書くと、メンバ変数として直接アクセスできる（匿名共用体）。
- ビットフィールド：構造体や共用体のメンバ変数の後ろに `:ビット数` と書くと、そのメンバ変数の大きさを指定できる。
- 構造体の最後のメンバを配列にし、メモリ領域を構造体のサイズよりも大きく確保することで、最後の要素を可変長配列にするテクニック（可変長配列メンバ）がある。
- コンマ演算子で式をつなぐと、先頭から順に式が評価され、評価結果は最後の式の値になる。
- マクロ中でトークン連結演算子 `##` を使うことで、その前後のトークンを連結して展開できる。
- マクロ中で文字列化演算子 `#` を使うことで、マクロ引数を文字列リテラルとして展開できる。
- 多次元配列のポインタは `型 (*変数名)[2番目の要素数]...[n番目の要素数]` と宣言できる。
- C 言語と C++ では関数名の内部表現が異なるため、 C++ から C 言語の関数を使う場合には関数プロトタイプ宣言の前に `extern "C"` を付ける。
  - C++ では、引数に関する情報や名前空間に関する情報を関数名の内部表現に加えている（name mangling）。
- 型修飾子 volatile を使うことで、コンパイラの最適化を阻害できる。
  - マルチスレッドプログラミングやメモリマップドI/Oを利用する場合などに用いる。
- 例外が最後まで補足されない場合や、二重例外が発生した場合などに terminate 関数が呼ばれ、terminate 関数は abort 関数を呼び出して異常終了する。
  - set_terminate 関数で terminate 関数の挙動を変更できる。
- 例外指定のついた関数から例外指定に含まれない例外を投げた場合、 unexpected 関数が呼ばれる。
  - unexpected 関数からさらに例外を投げた場合、再び例外指定をチェックし、例外指定に含まれていれば元の関数からその例外が投げられる。例外指定に含まれていない場合でも、例外指定に bad_exception が含まれていれば、例外が bad_exception に置き換えられ、元の関数から bad_exception が投げられる。

## 付録

- 付録 A：標準ヘッダファイル一覧
- 付録 B：演算子一覧
- 付録 C：C言語とC++の重要な相違点
- 付録 D：Boost ライブラリ
- 付録 E：参考文献
